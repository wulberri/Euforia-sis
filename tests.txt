// Import the functions to be tested
import { signup, signin, signout } from "../controllers/users.js";
import performance from "performance-now";

// Mock dependencies like the database and external modules
jest.mock("../database/db.js", () => {
  return {
    pool: {
      query: jest.fn(),
    },
  };
});
jest.mock("bcrypt", () => {
  return {
    hash: jest.fn(),
    compare: jest.fn(),
  };
});
jest.mock("../tokens/tokens.js", () => {
  return {
    generateAccessToken: jest.fn(),
    generateRefreshToken: jest.fn(),
    getUserEncrypt: jest.fn(),
  };
});

// Sample user data
const sampleUser = {
  id_usuario: 1,
  nombre: "John Doe",
  correo: "john@example.com",
  contrasena: "hashedpassword",
  rol: "usuario",
};

describe("signup", () => {
  it("should create a new user", async () => {
    // Mock the database query to return an empty result (user does not exist)
    const pool = require("../database/db.js").pool;
    pool.query.mockResolvedValueOnce([[]]);

    // Mock bcrypt.hash
    const bcrypt = require("bcrypt");
    bcrypt.hash.mockResolvedValue("hashedpassword");

    // Mock the database query for user creation
    pool.query.mockResolvedValueOnce({ affectedRows: 1 });

    const req = {
      body: {
        nombre: "John Doe",
        correo: "john@example.com",
        contrasena: "password",
      },
    };
    const res = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn(),
    };

    await signup(req, res);

    expect(res.status).toHaveBeenCalledWith(201);
    expect(res.json).toHaveBeenCalledWith({
      message: "Usuario registrado exitosamente",
    });
  });

  // Add more test cases for validation, existing user, and other scenarios
});

describe("signin", () => {
  it("should sign in a user with valid credentials", async () => {
    // Mock the database query to return a user with hashed password
    const pool = require("../database/db.js").pool;
    pool.query.mockResolvedValueOnce([sampleUser]);

    // Mock bcrypt.compare
    const bcrypt = require("bcrypt");
    bcrypt.compare.mockResolvedValue(true);

    // Mock the token generation
    const tokens = require("../tokens/tokens.js");
    tokens.generateAccessToken.mockReturnValue("access_token");
    tokens.generateRefreshToken.mockReturnValue("refresh_token");

    const req = {
      body: { correo: "john@example.com", contrasena: "password" },
    };
    const res = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn(),
    };

    await signin(req, res);

    expect(res.status).toHaveBeenCalledWith(200);
    expect(res.json).toHaveBeenCalledWith({
      user: sampleUser,
      accessToken: "access_token",
      refreshToken: "refresh_token",
    });
  });

  // Add more test cases for invalid credentials, user not found, and other scenarios
});

describe("signout", () => {
  it("should sign out a user", async () => {
    const req = { headers: { authorization: "refresh_token" } };
    const res = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn(),
    };

    // Mock the database query for token deletion
    const pool = require("../database/db.js").pool;
    pool.query.mockResolvedValueOnce({ affectedRows: 1 });

    await signout(req, res);

    expect(res.status).toHaveBeenCalledWith(200);
    expect(res.json).toHaveBeenCalledWith({
      mensaje: "Cerró sesión exitosamente",
    });
  });

  // Add more test cases for token not found and other scenarios
});

// Tests for dashboard and getAllUsers functions can be similarly structured with appropriate test scenarios.

describe("getAllUsers", () => {
  it("should measure the time of a database query", async () => {
    try {
      const startTime = performance(); // Registra el tiempo de inicio
      // Realiza la consulta a la base de datos
      const [result] = await pool.query(
        "SELECT `correo`,`nombre` FROM `usuario` WHERE `id_usuario` != ? AND `rol` = 'usuario'",
        [req.user.id_usuario]
      );
      const endTime = performance(); // Registra el tiempo de finalización

      // Calcula la duración de la consulta en milisegundos
      const queryTime = endTime - startTime;

      if (queryTime > 100) {
        // Ajusta el límite de tiempo según tus necesidades
        console.log(
          `La consulta de obtener todos los usuarios tardó ${queryTime} ms`
        );
      }

      // Define un límite de tiempo
      const queryTimeLimit = 100; // Ajusta el límite de tiempo según tus necesidades

      // Comprueba si el tiempo de consulta está dentro del límite
      expect(queryTime).toBeLessThanOrEqual(queryTimeLimit);

      return result; // Puedes ajustar la respuesta según tu necesidad
    } catch (error) {
      return error; // Puedes ajustar la respuesta en caso de error
    }
  });
});
